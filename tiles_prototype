dir_names = uids_of_paths({
        "ortho": rgb_path,
        "dsm": dsm_path
    })

cache_dir = "./.cache/"

overwrite = False

lock = threading.Lock()
dico = {}

req_q = queue.Queue()
resample_q = queue.Queue()

def dispatcher():
	while True:
		args = req_q.get()
		if os.path.isfile(args[1]):
			with lock:
				dico[args[1]] = ds.open_araster(args[1])
			req_q.task_done()
		else:
			resample_q.put(args)

def resampler():
	while True:
		args = resample_q.get()
		with lock:
			try:
				dico[args[1]]
			except KeyError:
				dico[args[1]] = resample_tile(*args)
		resample_q.task_done()
		req_q.task_done()



def get_input_tiles(fp, raster_path, fp_idx, input_w, cache_tile_width):

	tiles_per_input = np.ceil(input_w / cache_tile_width)

	input_tiles = []
	tiles_fps = ds.open_araster(raster_path).fp.tile(np.asarray((cache_tile_width, cache_tile_width)).T)

	# for i, j in zip(range(tiles_per_input), range(tiles_per_input)):
	# 	cache_tile_path = str(Path(cache_dir) / dir_names[frozenset({'ortho'})] / "rgba64_" +  + "_" +  + ".tif")

		req_q.put((raster_path, cache_tile_path, tile_fp))
	
		with lock:
	    	input_tiles.append(dico[cache_tile_path])


def resample_tile(raster_path, tile_path, tile_fp):
    src = ds.open_araster(raster_path)
    out = src.get_data(band=-1, fp=tile_fp)

    if len(src) == 4:
        out = np.where((out[...,3] == 255)[...,np.newaxis], out, 0)

    return ds.create_araster(tile_path, tile_fp, src.dtype, len(src), driver="GTiff", band_schema={"nodata": src.nodata}, sr=src.wkt_origin).set_data(out, band=-1)

